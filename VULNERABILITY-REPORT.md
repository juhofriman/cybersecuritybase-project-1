#SECMSG Vulnerability report

It has been noticed that service called SECMSG contains multiple major level vulnerabilities. Sources are available from https://github.com/juhofriman/cybersecuritybase-project-1 and application is made with JVM (Java Virtual Machine) hosted Clojure language. Clojure is a functional language in LISP tradition. Application does not have vast amount of dependencies, but they include ring (http server) and enlive (functional templating library). Comprehensive dependency listing is available at https://clojars.org/cybersecuritybase-project-1/versions/0.1.0-SNAPSHOT. Application is form based web application which does not include any javascript.

This document reports found vulnerabilities and suggests actions in order to make SECMSG more secure. Testing is done without https and it is expected that production deployments are served stricly from under https.

## 1. vulnerability: Insecure direct object reference

User can read private messages from the system without access.

### Steps to reproduce

1. login to system as user "bob"
2. note that bob has one private message
3. login to system as user "mark"
4. open any message user has received
5. alter query parameter (id=2)
6. a secret message is revealed

### Proposed fix

When a single message is queried, recipient should be checked against currently logged in user and return 404 if they do not match. Note that public messages should be visible to everybody who has valid credentials to the system.


## 2. vulnerability: session hijacking

Malicious user can hijack ongoing session because of the broken authentication mechanism. It looks like that session identifier is generated directly based on username and it is highly predictable.

### Steps to reproduce

1. Login to system as bob (init session)
2. Bob has cookie: ses_id=81b637d8fcd2c6da6359e6963113a1170de795e4b725b84d1e0b4cfd9ec58ce9, which looks like sha256
3. Try to make same hash from username. In os x terminal one can do this:
```
$ echo -n bob | shasum -a 256
81b637d8fcd2c6da6359e6963113a1170de795e4b725b84d1e0b4cfd9ec58ce9  -
```
4. From this we know that session id is generated directly from username
5. Open incognito browser and set session id
6. Browse Bob's messages and secrets

Bottom line is that attacker can hijack any session just by knowing username.

### Proposed fix

Session id must be generated randomly and it should not be based on something coming from user. Using random sha256 will work just fine.

## 3. vulnerability: cross site request forgery

Malicious attacker can try to trick users to make unintented operations. Currently this can be used to send messages in behalf on someone else.

1. Make a html page like this:
```
<!DOCTYPE html>
<html>
<body>

<h1>Win 1 000 000 Euros!</h1>

<form action="http://localhost:3000/new-message.html" method="POST">
  <input type="hidden" name="to" value="liz"/>
  <input type="hidden" name="topic" value="I WILL KILL YOU"/>
  <input type="hidden" name="message" value="I WILL KILL YOU LIZ"/>
  <input type="submit" value="Ready for sweet life? Press this!"/>
</form>

</body>
</html>

```
2. login as bob
3. open html page and you want to win 1 000 000 euros, so press the button
4. login do SECMSG as liz
5. see horrible message sent to liz by "bob"

### Proposed fix

Create CERF-token for every request and expect valid token from every form. This ensures forms are correctly generated from SECMSG backend and not from attackers.

## 4. vulnerability: password hash leak

Who made that /api/users? It exposes user password hashes directly.

### Steps to reproduce

1. Login as any user
2. Go to localhost:3000/api/users
3. Expect to see password hashes

### Proposed fix

This is really obvious: filter password out from interface. Passwords themselves are pretty strongly hashed but salting should be added to make them more secure.

## 5. Vulnerability: security misconfiguration

It's not wanted that unlogged user can read localhost:3000/secret.html

### Steps to reproduce

1. Open application and do not log in.
2. Go to  localhost:3000/secret.html
3. See sensitive data exposed without login

### Proposed fix

Application must disallow access to sensitive pages without login. Application should have an easy and comprehensive way to describe which pages are public and which are private.

## Additional notes

We strongly recommend using salts for persisting passwords to database as it increases cryptographic security greatly and is really simple to implement. We tested out various other threats and application is really defendant against cross site scripting as enlive escapes html automatically.